using System;
using System.Collections.Generic;
using AStar;
using sharonjl.utils;

namespace GraphSearch
{
	public class Node : INode
	{
		/// <summary>
		/// Precision of geohash codes.
		/// </summary>
		const int precision = 10;

		/// <summary>
		/// Static range in which a node can be declared as goal.
		/// Unit = Meters
		/// </summary>
		public static double GoalCriteria = 0.300;

		/// <summary>
		/// Empty node with all essential values null and inactive.
		/// </summary>
		public Node ()
		{
			id = null;
			LeftChild = null;
			RightChild = null;
			isActive = false;
		}

		/// <summary>
		/// lat = latutude
		/// lng = longitude
		/// IsActive = Flag to indicate if node is active [default=true].
		/// </summary>
		public Node (double lat, double lng, bool IsActive=true)
		{
			LeftChild = null;
			RightChild = null;

			id = Geohash.Encode(lat, lng, precision);

			Lat = lat;
			Lng = lng;

			isActive = IsActive;
		}

		/// <summary>
		/// GeoHash value of the node based on Lat and Lng.
		/// Autogenerated when node is initialized with Lat and Lng.
		/// </summary>
		public string id;

		private bool isOpenList = false;
		private bool isClosedList = false;

		/// <summary>
		/// Latitude.
		/// </summary>
		public double Lat;
		/// <summary>
		/// Longitude.
		/// </summary>
		public double Lng;

		/// <summary>
		/// Left Child of the current node.
		/// Left child is greater than the parent in value.
		/// </summary>
		public Node LeftChild;
		/// <summary>
		/// Right Child of the current node.
		/// Right child is smaller than the parent in value.
		/// </summary>
		public Node RightChild;

		/// <summary>
		/// A Flag to indicate if node is active or not.
		/// </summary>
		public bool isActive;

        /// <summary>
		/// Gets the total cost for this node.
		/// f = g + h
		/// TotalCost = MovementCost + EstimatedCost
		/// </summary>
		public int TotalCost { get { return MovementCost + EstimatedCost; } }

		/// <summary>
		/// Gets the movement cost for this node.
		/// This is the movement cost from this node to the starting node, or g.
		/// </summary>
		public int MovementCost { get; private set; }

		/// <summary>
		/// Gets the estimated cost for this node.
		/// This is the heuristic from this node to the goal node, or h.
		/// </summary>
		public int EstimatedCost { get; private set; }

		/// <summary>
		/// Preceding node in graph.
		/// </summary>
        public INode Parent { get; set; }

		/// <summary>
		/// List of childern
		/// </summary>
        public IEnumerable<INode> Children{ 
			get
			{
				var children = new List<Node>();
				if(LeftChild != null)
					children.Add(LeftChild);
				if(RightChild != null)
					children.Add(RightChild);
				return children;
			}}

        public bool IsClosedList(IEnumerable<INode> closedList)
        {
            return isClosedList;
        }

        public bool IsGoal(INode goal)
        {
			// var g = (Node) goal;
            // return (this.Lat == g.Lat && this.Lng == g.Lng);

			var g = (Node) goal;
			const double max_cost = 999999.99;
//			double distLeft = max_cost, distRight = max_cost, dist;


			double dist = Helper.distFrom(g.Lat, g.Lng, Lat, Lng);

			if (dist <= GoalCriteria) 
			{
				double distLeft = max_cost, distRight = max_cost;
				if(LeftChild != null)
					distLeft = Helper.distFrom(g.Lat, g.Lng, LeftChild.Lat, LeftChild.Lng);

				if(RightChild != null)
					distRight = Helper.distFrom(g.Lat, g.Lng, RightChild.Lat, RightChild.Lng);	

				 if(distLeft == max_cost && distRight == max_cost) // Node has no child
				 	return true;
				 else if(distRight > dist && distLeft > dist) // Childeren are away from goal
				 	return true;
			}

			return false;
        }

        public bool IsOpenList(IEnumerable<INode> openList)
        {
            return isOpenList;
        }

        public void SetClosedList(bool value)
        {
            isClosedList = value;
        }

        public void SetEstimatedCost(INode goal)
		{
			var g = (Node)goal;
			double cost = Helper.distFrom(Lat, Lng, g.Lat, g.Lng);

			// Since the distance is in meters so we can intuitively convert it to int
			this.EstimatedCost = Convert.ToInt32(cost);
		}

        public void SetMovementCost(INode parent)
		{
			this.MovementCost = parent.MovementCost + 1;
		}

        public void SetOpenList(bool value)
        {
            isOpenList = value;
        }
    }
}

